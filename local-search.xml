<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>循环队列：解决数组实现队列的效率问题</title>
    <link href="/2023/04/05/circularqueue/"/>
    <url>/2023/04/05/circularqueue/</url>
    
    <content type="html"><![CDATA[<h1 id="循环队列：解决数组实现队列的效率问题"><a href="#循环队列：解决数组实现队列的效率问题" class="headerlink" title="循环队列：解决数组实现队列的效率问题"></a>循环队列：解决数组实现队列的效率问题</h1><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>队列是编程中常用的一种的一种数据结构，它具有先进先出的特性（First In First Out, FIFO）。通常我们可以使用多种方式来实现队列这种数据结构：</p><table><thead><tr><th>实现方式</th><th>优缺点分析</th></tr></thead><tbody><tr><td>用数组实现队列</td><td>由于数组可以随机访问的特性，队列中head和tail指针的移动效率会比较高，同时队列所占的内存应当比较小。但是也是由于数组需要申请连续内存空间的缘故，导致当tail节点超出数组范围的时候，就需要对数组进行扩容，而这种扩容的效率是不可忽视且比较低的。</td></tr><tr><td>用链表实现队列</td><td>由于链表方便插入和删除的特性，只需要维护链表头和尾的元素就可以，实现方便，不需要大规模不确定扩容。但是由于链表的特性，内存容易碎片化，利用效率低，同时会多占用一倍左右的内存（单链表），也降低了入队出队的效率。</td></tr><tr><td>用一对耦合的栈实现队列</td><td>活跃思维？同时利用好栈的封装和API应该会剩下很多写代码的时间，不过队列不是也有封装吗？</td></tr></tbody></table><p>由于链表实现队列对内存的影响较大，这里探究怎么提高使用数组实现队列的效率。</p><h3 id="用数组实现队列的问题"><a href="#用数组实现队列的问题" class="headerlink" title="用数组实现队列的问题"></a>用数组实现队列的问题</h3><p>回顾在用数组实现栈的过程当中，当我们执行入栈出栈的过程当中，如果栈的空间不足，则可以将栈的空间扩容2倍。那么这个扩容过程的时间复杂度是多少呢，不难分析出应该是<code>O(n)</code>，因为我们需要在内存中新开辟一片空间，并且把之前所有的数据搬迁回去。</p><p>如果将队列的扩容和栈的扩容简单的画上等号，认为其时间复杂度都是<code>O(n)</code>，那就是错误的，因为我们可以将栈扩容所用的<code>O(n)</code>时间均摊给扩容后可入栈的n个位置中每次入栈操作（如果每次扩容两倍），实际上入栈的时间复杂度就是<code>O(1)</code>。</p><p>但是队列的入队出队导致的扩容次数是无法预测的，除非我们采用牺牲内存空间的方式。由于在一段定长的数组中，假定是10位<code>int</code>长度，<code>head</code>指向第4位而<code>tail</code>指向第9位。此时，如果我们要执行入队操作，是申请一块更大的内存空间还是同样大的内存空间呢？如果申请更大的内存空间，那么<code>head</code>前的区域必定产生大量的内存浪费。如果申请同等大小的内存空间，可预见的是不需要几次入队操作便又需要对数组进行搬迁。因此，我们急需一种更加合理的实现。</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>模运算的具体定义与概念可以参见维基百科：</p><p><a href="https://zh.wikipedia.org/zh-sg/%E6%A8%A1%E9%99%A4">维基百科关于模运算的定义</a></p><p>模运算有时候也称为时钟运算。你可以看看你房间里那个12小时的时钟。</p><p>你在钟上看到了12个数字，这里，模数为12，剩余的12个模数为0、1、2，..11，所以，当你给出时间时，你实际上给出了一个介于0和11之间的余数。</p><h3 id="循环队列的概念"><a href="#循环队列的概念" class="headerlink" title="循环队列的概念"></a>循环队列的概念</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[1, 2, 4, 6, x, x, x, 2, 3, 4]<br>             |tail    |head<br></code></pre></td></tr></table></figure><p>循环队列中，将数组视为首位相接的，<code>tail</code>指向“顺时针”（下标模运算呈现周期性单增德的方向）的末尾元素后的空位。在这里，模运算是以数组长度<code>l</code>为模的运算。</p><p>具体问题的实现如下：</p><ol><li><p><code>enqueue</code> 入队操作</p><p> 判断是否需要扩容：在这里，判断的方法是，在模运算中，<code>tail == head - 1</code> 如果不需要扩容则修改<code>tail</code>当前下标的值，如果需要扩容则调用扩容方法之后再操作。最后将<code>tail</code> 以模运算后移一位。</p></li><li><p><code>dequeue</code> 出队操作</p><p> 范围 <code>head</code> 所在下标的值，然后将 <code>head</code> 以模运算后移一位。</p></li><li><p>扩容操作：</p><p> 申请一个更大的数组（可以是两倍大小），然后按照模运算的规则从<code>head</code> 到<code>tail - 1</code> 遍历原数组，并移入新数组的<code>[0] ~ [n - 2]</code> 位置中，n为原数组的大小。</p></li></ol><h3 id="循环数组的实现"><a href="#循环数组的实现" class="headerlink" title="循环数组的实现"></a>循环数组的实现</h3><p><code>CircularQueue.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularQueue</span> &#123;<br>    <span class="hljs-type">int</span> * buffer;<br>    <span class="hljs-type">unsigned</span> m_size;<br>    <span class="hljs-type">unsigned</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> head, tail;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> initSize;<br><br>    <span class="hljs-built_in">CircularQueue</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CircularQueue</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> sz)</span></span>;<br>    ~<span class="hljs-built_in">CircularQueue</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dequeue</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>CircularQueue.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CircularQueue.h&quot;</span></span><br><br><br><span class="hljs-type">unsigned</span> CircularQueue::initSize = <span class="hljs-number">1000</span>;<br><br><br>CircularQueue::<span class="hljs-built_in">CircularQueue</span>() &#123;<br>    buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[initSize];<br>    m_size = initSize;<br>    head = <span class="hljs-number">0</span>;<br>    tail = <span class="hljs-number">0</span>;<br>&#125;<br><br><br>CircularQueue::<span class="hljs-built_in">CircularQueue</span>(<span class="hljs-type">unsigned</span> sz)&#123;<br>    m_size = sz + <span class="hljs-number">1</span>;<br>    buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m_size];<br>    head = <span class="hljs-number">0</span>;<br>    tail = <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CircularQueue::transfer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> * old = buffer;<br>    buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m_size * <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = head, j = <span class="hljs-number">0</span>; i != tail; (i++, j++))&#123;<br>        <span class="hljs-keyword">if</span>(i == m_size) i = <span class="hljs-number">0</span>;<br>        buffer[j] = old[i];<br>    &#125;<br>    head = <span class="hljs-number">0</span>;<br>    tail = m_size - <span class="hljs-number">1</span>;<br>    m_size *= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">delete</span> old;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CircularQueue::enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>((head - tail) % m_size == <span class="hljs-number">1</span>) <span class="hljs-built_in">transfer</span>();<br>    buffer[tail] = x;<br>    ++tail;<br>    ++cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">CircularQueue::size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CircularQueue::isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CircularQueue::top</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isEmpty</span>())&#123;<br>        <span class="hljs-keyword">return</span> buffer[head];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CircularQueue::dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isEmpty</span>())&#123;<br>        ans = buffer[head];<br>        head += <span class="hljs-number">1</span>;<br>        head %= m_size;<br>        --cnt;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ans = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br>CircularQueue::~<span class="hljs-built_in">CircularQueue</span>() &#123;<br>    <span class="hljs-keyword">delete</span> buffer;<br>    buffer = <span class="hljs-literal">nullptr</span>;<br>    m_size = <span class="hljs-number">0</span>;<br>    cnt = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>队列</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于python中Y组合子的问题讨论（补档）</title>
    <link href="/2023/04/05/python-Ycombination/"/>
    <url>/2023/04/05/python-Ycombination/</url>
    
    <content type="html"><![CDATA[<h1 id="关于python中Y组合子的问题讨论"><a href="#关于python中Y组合子的问题讨论" class="headerlink" title="关于python中Y组合子的问题讨论"></a>关于python中Y组合子的问题讨论</h1><blockquote><p>by Wenze Jin</p></blockquote><p>在 <em><strong>The Structure and Interpretation of Computer Programs</strong></em> 这门课的hw03-Recursion中有如下的 <em><strong>JUST FOR FUN</strong></em>拓展问题，值得研究。  </p><h2 id="Problem-7-Anonymous-factorial"><a href="#Problem-7-Anonymous-factorial" class="headerlink" title="Problem 7: Anonymous factorial"></a><a href="https://sicp.pascal-lab.net/2022/homework/hw03/3_1.html#problem-7-anonymous-factorial-0pts">Problem 7: Anonymous factorial</a></h2><p>The recursive factorial function can be written as a single expression by using a <a href="http://docs.python.org/py3k/reference/expressions.html#conditional-expressions">conditional expression</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>fact = <span class="hljs-keyword">lambda</span> n: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> mul(n, fact(sub(n, <span class="hljs-number">1</span>)))<br><span class="hljs-meta">&gt;&gt;&gt; </span>fact(<span class="hljs-number">5</span>)<br><span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><blockquote><p>The ternary operator <code>&lt;a&gt; if &lt;bool-exp&gt; else &lt;b&gt;</code> evaluates to <code>&lt;a&gt;</code> if <code>&lt;bool-exp&gt;</code> is truthy and evaluates to <code>&lt;b&gt;</code> if <code>&lt;bool-exp&gt;</code> is false-y.</p></blockquote><p>However, this implementation relies on the fact (no pun intended) that <code>fact</code> has a name, to which we refer in the body of <code>fact</code>. To write a recursive function, we have always given it a name using a <code>def</code> or assignment statement so that we can refer to the function within its own body. In this question, your job is to define fact recursively without giving it a name!</p><p>Write an expression that computes <code>n</code> factorial using only call expressions, conditional expressions, and lambda expressions (no assignment or def statements). <em>Note in particular that you are not allowed to use <code>make_anonymous_factorial</code> in your return expression.</em> The <code>sub</code> and <code>mul</code> functions from the <code>operator</code> module are the only built-in functions required to solve this problem:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> sub, mul<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_anonymous_factorial</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;Return the value of an expression that computes factorial.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; make_anonymous_factorial()(5)</span><br><span class="hljs-string">    120</span><br><span class="hljs-string">    &gt;&gt;&gt; from construct_check import check</span><br><span class="hljs-string">    &gt;&gt;&gt; # ban any assignments or recursion</span><br><span class="hljs-string">    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;make_anonymous_factorial&#x27;, [&#x27;Assign&#x27;, &#x27;AugAssign&#x27;, &#x27;FunctionDef&#x27;, &#x27;Recursion&#x27;])</span><br><span class="hljs-string">    True</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;YOUR_EXPRESSION_HERE&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>题设要求我们构建一个可以求<code>n</code>的阶乘的递归函数。</p><h4 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h4><p>在我们的认识中，解决这样的问题通常可以使用这样的递归函数来解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorialR</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> n * factorialR(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>同时我们又知道：</p><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> x: x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以创建一个匿名函数，这个函数需要一个参数x，实现功能是返回x + 1</p><p><strong>例如</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f1 = <span class="hljs-keyword">lambda</span> x: x + <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f1(<span class="hljs-number">2</span>)<br><span class="hljs-number">3</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-keyword">lambda</span> x: x + <span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)<br><span class="hljs-number">3</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> x: f(x + <span class="hljs-number">1</span>))(f1)(<span class="hljs-number">2</span>)<br><span class="hljs-number">4</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>if_test = <span class="hljs-keyword">lambda</span> x: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>[if_test(<span class="hljs-number">10</span>), if_test(<span class="hljs-number">0</span>), if_test(-<span class="hljs-number">10</span>)]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="lambda表达式的实现"><a href="#lambda表达式的实现" class="headerlink" title="lambda表达式的实现"></a>lambda表达式的实现</h4><p>可以如下用一个有名称的lambda表达式简洁的实现这个递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>factlambda = <span class="hljs-keyword">lambda</span> x: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x * factlambda(x - <span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>factlambda(<span class="hljs-number">5</span>)<br><span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><h4 id="但是！！！"><a href="#但是！！！" class="headerlink" title="但是！！！"></a>但是！！！</h4><p>题目的要求是让我们输出一个匿名的lambda函数，也就是它不可以有名字，理论上不可以调用自己！同时题目为了防止我们偷鸡，会在代码中检查你有没有赋值，定义函数，调用自身函数以实现递归的功能。</p><p>有如下答案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_anonymous_factorial</span>():<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">lambda</span> fact: <span class="hljs-keyword">lambda</span> k: fact(fact,k))(<span class="hljs-keyword">lambda</span> factcopy, k: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> k * factcopy(factcopy,k-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>在这个答案中我们可以看到如下流程：</p><ol><li><p>定义一个 lambda 它需要一个参数 fact，它的功能是返回一个需要一个参数k的函数，并且指定fact的参数数目为两个</p></li><li><p>在右侧的括号中，整个形成一个lambda function，作为左侧括号中的fact参数，这个函数接受两个参数<code>factcopy</code>,<code>k</code>并对k进行判断 实现一个阶乘的功能</p></li><li><p>我们可以将右侧的函数理解为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">factcopy, k</span>):<br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> k * factcopy(factcopy, k - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这样一个递归的框架，相比较普通的递归，我们发现参数多了一个<code>factcopy</code>这是因为，这是一个匿名函数！没有其他人帮你记住你叫什么名字，如果我们想要知道自己叫什么，我们必须写一个小纸条把自己的名字记住！</p><p>现在还差一步：记自己名字的纸条准备好了，还差搞清楚自己叫什么！</p></li><li><p>在进行调用的过程中，如果我们为左侧的函数提供一个k，左侧则会调用右侧函数，变为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> k: f(f, k)<br></code></pre></td></tr></table></figure><blockquote><p>f 是我们根据上面的理解假设的一个名字，便于理解这个函数的结构，实际上匿名函数是没有名字的</p></blockquote><p>现在，我们就能理解左侧括号内的功能了：</p><ol><li>告诉右侧函数，你叫自己！ 现在你可以用 <code>自己(自己，k)</code>调用自己了！</li><li>生成一个需要一个参数值<code>k</code>的函数</li></ol></li></ol><h3 id="最终解答"><a href="#最终解答" class="headerlink" title="最终解答"></a>最终解答</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_anonymous_factorial</span>():<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">lambda</span> fact: <span class="hljs-keyword">lambda</span> k: fact(fact,k))(<span class="hljs-keyword">lambda</span> factcopy, k: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> k * factcopy(factcopy,k-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>于是，这题到这就结束了，引出了下题的重要概念与思想</p><h2 id="Problem-8-All-Ys-Has-Been"><a href="#Problem-8-All-Ys-Has-Been" class="headerlink" title="Problem 8: All-Ys Has Been"></a><a href="https://sicp.pascal-lab.net/2022/homework/hw03/3_2.html#problem-8-all-ys-has-been-0pts">Problem 8: All-Ys Has Been</a></h2><p>Given mystery function <code>Y</code>, complete <code>fib_maker</code> and <code>number_of_six_maker</code> so that the given doctests work correctly.</p><p>When <code>Y</code> is called on <code>fib_maker</code>, it should return a function which takes a positive integer <code>n</code> and returns the <code>n</code>th Fibonacci number.</p><p>Similarly, when <code>Y</code> is called on <code>number_of_six_maker</code> it should return a function that takes a positive integer <code>x</code> and returns the number of times the digit 6 appears in <code>x</code>.</p><blockquote><p>Hint: You may use the ternary operator <code>&lt;a&gt; if &lt;bool-exp&gt; else &lt;b&gt;</code>, which evaluates to <code>&lt;a&gt;</code> if <code>&lt;bool-exp&gt;</code> is truthy and evaluates to <code>&lt;b&gt;</code> if <code>&lt;bool-exp&gt;</code> is false-y.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">Y = <span class="hljs-keyword">lambda</span> f: (<span class="hljs-keyword">lambda</span> x: x(x))(<span class="hljs-keyword">lambda</span> x: f(<span class="hljs-keyword">lambda</span> z: x(x)(z)))<br>fib_maker = <span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> r: <span class="hljs-string">&#x27;YOUR_EXPRESSION_HERE&#x27;</span><br>number_of_six_maker = <span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> r: <span class="hljs-string">&#x27;YOUR_EXPRESSION_HERE&#x27;</span><br><br>my_fib = Y(fib_maker)<br>my_number_of_six = Y(number_of_six_maker)<br><br><span class="hljs-comment"># This code sets up doctests for my_fib and my_number_of_six.</span><br><br>my_fib.__name__ = <span class="hljs-string">&#x27;my_fib&#x27;</span><br>my_fib.__doc__=<span class="hljs-string">&quot;&quot;&quot;Given n, returns the nth Fibonacci nuimber.</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>my_fib(0)</span><br><span class="hljs-string">0</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>my_fib(1)</span><br><span class="hljs-string">1</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>my_fib(2)</span><br><span class="hljs-string">1</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>my_fib(3)</span><br><span class="hljs-string">2</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>my_fib(4)</span><br><span class="hljs-string">3</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>my_fib(5)</span><br><span class="hljs-string">5</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>my_number_of_six.__name__ = <span class="hljs-string">&#x27;my_number_of_six&#x27;</span><br>my_number_of_six.__doc__=<span class="hljs-string">&quot;&quot;&quot;Return the number of 6 in each digit of a positive integer n.</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>my_number_of_six(666)</span><br><span class="hljs-string">3</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>my_number_of_six(123456)</span><br><span class="hljs-string">1</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>在上题思想的基础上，本题定义了一个常量Y</p><blockquote><p>其实Y就是我们所说的Y组合子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Y = <span class="hljs-keyword">lambda</span> f: (<span class="hljs-keyword">lambda</span> x: x(x))(<span class="hljs-keyword">lambda</span> x: f(<span class="hljs-keyword">lambda</span> z: x(x)(z)))<br></code></pre></td></tr></table></figure><p>改个熟悉的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Y = <span class="hljs-keyword">lambda</span> f: (<span class="hljs-keyword">lambda</span> x: x(x))(<span class="hljs-keyword">lambda</span> xcopy: f(<span class="hljs-keyword">lambda</span> z: xcopy(xcopy)(z)))<br></code></pre></td></tr></table></figure><h4 id="Y组合子语义分析"><a href="#Y组合子语义分析" class="headerlink" title="Y组合子语义分析"></a>Y组合子语义分析</h4><p><code>Y</code>指向了一个lambda函数，这个函数的功能是获得一个<code>f</code>，对其进行如下操作：</p><ol><li><p>观察这个函数的内部，我们可以发现，函数的左侧括号内定义了一个函数，这个函数需要一个输入参数x</p><ul><li>它的功能是返回一个东西，即将<code>x</code>作为<code>x</code>的参数时生成的东西</li><li>同时它指定了<code>x</code>的参数数目为一个</li><li>它看起来非常像我们在上题当中说到的告诉右边那个笨笨的函数自己叫做<em><strong>“自己”</strong></em></li></ul></li><li><p>接下来我们看一下右边那个笨笨的函数是什么，可以把它写成这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">benben</span>(<span class="hljs-params">xcopy, f</span>):<br>    <span class="hljs-keyword">return</span>  f(<span class="hljs-keyword">lambda</span> z: xcopy(xcopy, f)(z))<br></code></pre></td></tr></table></figure></li><li><p>这个函数需要一个参数 <code>xcopy</code> <em>（不是刚才那个x）</em> 以及从外面的lambda表达式里拿进来的f</p><ul><li>它的功能是，应用最外侧函数输入的函数<code>f</code>，并再次需要一个参数<code>z</code> </li><li>告诉<code>benben</code>自己叫做<code>benben</code> 也就是 <code>xcopy = benben</code></li><li>指定了最外侧输入的f函数参数为一个函数</li><li>嵌套应用了很多次f形成了一个对f的递归，你会发现，<code>benben</code>返回的应该还是一个函数，因为<code>xcopy(xcopy, f)</code>后仍需要一个参数z</li><li>这并不难理解，因为f的括号内还是一个<code>lambda</code>表达式，他需要一个参数<code>z</code></li><li>到现在为止，我们对整个函数的运行方式有了粗略的理解，但仍不清楚具体的实现方式</li></ul></li></ol><h4 id="Y组合子功能实现"><a href="#Y组合子功能实现" class="headerlink" title="Y组合子功能实现"></a>Y组合子功能实现</h4><p>现在，我们需要利用Y组合子的这些特性完成下面两个任务</p><h5 id="1-实现第n个Fibonacci数的计算"><a href="#1-实现第n个Fibonacci数的计算" class="headerlink" title="1. 实现第n个Fibonacci数的计算"></a>1. 实现第n个Fibonacci数的计算</h5><p><strong>题面：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Y = <span class="hljs-keyword">lambda</span> f: (<span class="hljs-keyword">lambda</span> x: x(x))(<span class="hljs-keyword">lambda</span> x: f(<span class="hljs-keyword">lambda</span> z: x(x)(z)))<br>fib_maker = <span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> r: <span class="hljs-string">&#x27;YOUR_EXPRESSION_HERE&#x27;</span><br>my_fib = Y(fib_maker)<br></code></pre></td></tr></table></figure><p>我们需要完善这个<code>fib_maker</code></p><p><strong>解答</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fib_maker = <span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> r: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> r == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> r == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> f(r - <span class="hljs-number">1</span>) + f(r - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>此时 <code>fib_maker</code> 就是一个函数， 它请求一个方法f 请求一个参数r</p><p>通过上面的分析， <code>fib_maker</code>这个函数会被应用于<code>f</code>，在<code>benben</code>函数中，每次都会调用一次<code>fib_maker</code>，每次调用的结果：</p><ul><li>它的参数f是一个请求更高阶数参数的<code>fib_maker</code></li><li>它需要一个当前阶数的r参数</li></ul><p>至此，我们发现，<code>benben</code>教会了<code>fib_maker</code>每次调用自己并请求一个参数哦~</p><h5 id="2-实现统计一个数字中有几个六"><a href="#2-实现统计一个数字中有几个六" class="headerlink" title="2. 实现统计一个数字中有几个六"></a>2. 实现统计一个数字中有几个六</h5><p><strong>题面</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Y = <span class="hljs-keyword">lambda</span> f: (<span class="hljs-keyword">lambda</span> x: x(x))(<span class="hljs-keyword">lambda</span> x: f(<span class="hljs-keyword">lambda</span> z: x(x)(z)))<br>number_of_six_maker = <span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> r: <span class="hljs-string">&#x27;YOUR_EXPRESSION_HERE&#x27;</span><br>my_number_of_six = Y(number_of_six_maker)<br></code></pre></td></tr></table></figure><p>我们需要完善这个<code>my_number_of_six</code></p><p>这个在本次作业先前的<code>Problem1</code>中有提到原递归式函数为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">number_of_six</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Return the number of 6 in each digit of a positive integer n.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; number_of_six(666)</span><br><span class="hljs-string">    3</span><br><span class="hljs-string">    &gt;&gt;&gt; number_of_six(123456)</span><br><span class="hljs-string">    1</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> n % <span class="hljs-number">10</span> == <span class="hljs-number">6</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + number_of_six(n // <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> number_of_six(n // <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">number_of_six_maker = <span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> r: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> r == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> + f(r // <span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> r % <span class="hljs-number">10</span> == <span class="hljs-number">6</span> <span class="hljs-keyword">else</span> f(r // <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>此时<code>number_of_six_maker</code>是一个函数，它要求一个方法<code>f</code>，一个参数r</p><p>和上面同样的，<code>benben</code>函数使得<code>number_of_six_maker</code>:</p><ul><li>的f是请求一个参数的更高阶数<code>number_of_six_maker</code></li><li>它需要一个当前阶数的参数r</li></ul><p>至此，<code>benben</code>又教会了<code>number_of_six_maker</code>自己叫什么，自己调用自己与自己吃饭饭哦~</p><p>至此，我们也学会了怎么去完成一个匿名递归函数哦<em><strong>（运用Y组合子）</strong></em></p><h3 id="最终解答-1"><a href="#最终解答-1" class="headerlink" title="最终解答"></a>最终解答</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fib_maker = <span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> r: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> r == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> r == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> f(r - <span class="hljs-number">1</span>) + f(r - <span class="hljs-number">2</span>)<br>number_of_six_maker = <span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> r: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> r == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> + f(r // <span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> r % <span class="hljs-number">10</span> == <span class="hljs-number">6</span> <span class="hljs-keyword">else</span> f(r // <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h2 id="我们从Y组合子中获得了什么"><a href="#我们从Y组合子中获得了什么" class="headerlink" title="我们从Y组合子中获得了什么"></a>我们从Y组合子中获得了什么</h2><p>到此为止，我们通过Y组合子的方式，仅通过λλ演算的概念，实现了「递归」的概念。因此，可以论证出「递归」这个概念可以在函数式编程语言中是「派生」的，而不需要「原生」支持。我们仅仅需要λ演算就能模拟自然数<code>（hw02-Higher-Order-Funtions-JFF）</code>、运算<code>（hw02-Higher-Order-Funtions-JFF）</code>、递归这些概念了。</p><blockquote><p>笔者因专业知识有限，如有疏漏，欢迎交流！</p><p>Email: <a href="mailto:&#119;&#x65;&#x6e;&#122;&#x65;&#x6a;&#x69;&#110;&#x32;&#x30;&#x30;&#x34;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;">&#119;&#x65;&#x6e;&#122;&#x65;&#x6a;&#x69;&#110;&#x32;&#x30;&#x30;&#x34;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a></p><p>金文泽 Wenze Jin</p><p>Nanjing University</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言/Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>函数式</tag>
      
      <tag>lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇文章</title>
    <link href="/2023/04/05/first-post/"/>
    <url>/2023/04/05/first-post/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h1><p>Hi，这里是Wenze Jin的个人技术博客。</p><p>这里将用来分享一些学习笔记与技术性的内容，同时也会分享一些关于当下科技热点的观点。</p><p>如果有技术性的问题欢迎交流👏</p><blockquote><p>我的 Github: <a><a href="https://github.com/WenzeJin">https://github.com/WenzeJin</a></a></p></blockquote><p>由于本人学识疏浅，专业问题上如有疏漏，还请各位斧正。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
